Demo Video requirements
In your demo video, please cover the demo of the actual thing you’ve built, covering:
System design & implementation


components and responsibilities


end-to-end flow: create store → resources created → store ready → place order → delete store


Isolation, resources, reliability


how stores are isolated (namespaces, secrets, PVCs)


requests/limits and any quotas/guardrails


idempotency and failure handling


cleanup guarantees


Security posture


secret handling


RBAC / least privilege approach


what’s exposed publicly vs internal-only


basic container hardening (where applicable)


Horizontal scaling plan


what scales horizontally (API, orchestrator, dashboard)


how you’d scale provisioning throughput


stateful constraints and how you’d handle them


Abuse prevention


rate limiting / quotas (per user or per IP)


blast-radius controls (max stores, max resources, timeouts)


audit trail/logging for actions


Local-to-VPS production story


what changes between local and VPS via Helm values


ingress, domains, storage, secrets strategy


upgrade/rollback approach with Helm



Deliverables (in the repo)
README.md including:


local setup instructions


VPS/production-like setup instructions (k3s is fine)


how to create a store and place an order


Source code for dashboard + backend + provisioning/orchestration


Helm chart(s) + values files (local vs prod)


Short “System design & tradeoffs” note covering:


architecture choice


idempotency/failure handling/cleanup approach


what changes for production (DNS, ingress, storage class, secrets, etc.)
Ways to Stand Out
These will be strong differentiators if implemented well.
1) Production-like VPS deployment
Deploy the same Helm charts on a VPS (k3s) and show it working.


Document what changed via Helm values (domain/ingress/storage/secrets).


Optional: TLS (cert-manager) setup notes.


Optional: Add in dashboard for people to link their domain to the store.


Deploy live on AWS or google free tier.


2) Stronger multi-tenant isolation and guardrails
Namespace-level ResourceQuota + LimitRange per store.


Optional: max PVC size per store; default requests/limits for pods.


3) Idempotency and recovery
Store creation is safe to retry (no duplicate resources, clean reconcile).


If the provisioning component restarts mid-provisioning, the system recovers or fails cleanly with clear status.


4) Abuse prevention beyond rate limiting
Per-user/store quotas (e.g., max stores per user).


Timeouts for provisioning.


Audit log: who created/deleted what and when.


5) Observability
Store-level events or a small activity log surfaced in the dashboard.


Basic metrics (e.g., stores created, provisioning failures, provisioning duration).


Clear “why it failed” reporting when something breaks.


6) Network and security hardening
Basic RBAC with least privilege for provisioning component.


NetworkPolicies per store namespace (deny-by-default with required allows).


Run containers as non-root where possible.


7) Scaling plan (implemented, not just described)
Horizontal scaling for platform components (API/dashboard/orchestrator).


Concurrency controls for provisioning multiple stores safely.


8) Upgrades and rollback story
Demonstrate or document how you’d upgrade store versions (images/chart values) and roll back safely with Helm.


